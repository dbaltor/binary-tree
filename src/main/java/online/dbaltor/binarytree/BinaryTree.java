/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package online.dbaltor.binarytree;

import java.util.ArrayDeque;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.Queue;
import java.util.function.Consumer;

public class BinaryTree {

    public static record TreeNode<T extends Comparable<T>>(Optional<TreeNode<T>> left, Optional<TreeNode<T>> right, T value) implements Comparable<TreeNode<T>> {

        @Override
        public int compareTo(TreeNode<T> other) {
             return value.compareTo(other.value);   
        }
    }

    public static <T extends Comparable<T>> Optional<TreeNode<T>> add(Optional<TreeNode<T>> tree, T valueToAdd) {
        return Optional.of(
            tree
                .map(node -> {
                    var sigNum = Integer.signum(valueToAdd.compareTo(node.value));

                    return switch (sigNum) {
                        case -1 -> new TreeNode<>(add(node.left, valueToAdd), node.right, node.value);
                        case +1 -> new TreeNode<>(node.left, add(node.right, valueToAdd), node.value);
                        default -> node; // node is already in the tree
                    };
                })
                .orElse(new TreeNode<>(Optional.empty(), Optional.empty(), valueToAdd)));
    }

    public static <T extends Comparable<T>> void in_order_dfs_traversal(Optional<TreeNode<T>> tree, Consumer<T> consumer) {
        tree.ifPresent(node -> {
            in_order_dfs_traversal(node.left, consumer);
            consumer.accept(node.value);
            in_order_dfs_traversal(node.right, consumer);
        });
    }

    public static <T extends Comparable<T>> void pre_order_dfs_traversal(Optional<TreeNode<T>> tree, Consumer<T> consumer) {
        tree.ifPresent(node -> {   
            consumer.accept(node.value);
            pre_order_dfs_traversal(node.left, consumer);
            pre_order_dfs_traversal(node.right, consumer);
        });
    }
    public static <T extends Comparable<T>> void post_order_dfs_traversal(Optional<TreeNode<T>> tree, Consumer<T> consumer) {
        tree.ifPresent(node -> {
            post_order_dfs_traversal(node.left, consumer);
            post_order_dfs_traversal(node.right, consumer);
            consumer.accept(node.value);
        });
    }

    public static <T extends Comparable<T>> void bfs_traversal(Optional<TreeNode<T>> tree, Consumer<T> consumer) {
        tree.ifPresent(node -> {
            Queue<TreeNode<T>> queue = new ArrayDeque<>();
            
            while(true) {
                consumer.accept(node.value);
                // queue children
                node.left.ifPresent(child -> queue.add(child));
                node.right.ifPresent(child -> queue.add(child));
                // dequeue the next node to process
                try {
                    node = queue.remove();
                } catch (NoSuchElementException e) {
                    break;
                }
            }
        });
    }

    public static <T extends Comparable<T>> int depth(Optional<TreeNode<T>> tree) {
        return tree
            .map(node -> Integer.max(depth(node.left), depth(node.right)) + 1)
            .orElse(0);
    }

    public static  <T extends Comparable<T>> Optional<T> maximum(Optional<TreeNode<T>> tree) {
        Optional<T> max = Optional.empty();

        while(tree.isPresent()) {
            max = Optional.of(tree.get().value);
            tree = tree.get().right;
        }
        return max;
    }

    public static  <T extends Comparable<T>> Optional<T> minimum(Optional<TreeNode<T>> tree) {
        Optional<T> min = Optional.empty();

        while(tree.isPresent()) {
            min = Optional.of(tree.get().value);
            tree = tree.get().left;
        }
        return min;
    }

    public static <T extends Comparable<T>> Optional<TreeNode<T>> remove(final Optional<TreeNode<T>> tree, final T valueToRemove) {
        return tree
            .flatMap( node ->  {
                var sigNum = Integer.signum(valueToRemove.compareTo(node.value));

                return switch (sigNum) {
                    case -1 -> Optional.of(new TreeNode<>(remove(node.left, valueToRemove),node.right, node.value));
                    case +1 -> Optional.of(new TreeNode<>(node.left, remove(node.right, valueToRemove), node.value));
                    default ->  { // FOUND IT!
                        if(node.left.isEmpty() && node.right.isEmpty()) { // node is a leaf
                            yield Optional.empty();
                        }
                        else if(node.left.isEmpty()) { // node with only the right child
                            yield node.right;
                        }
                        else if(node.right.isEmpty()) { // node with only the left child
                            yield node.left;
                        }
                        else { // node with both children
                            // Replace this node for the lowest value from the right sub-branch and remove that from its orignal place
                            var replacement = minimum(node.right).get();
                            yield Optional.of(new TreeNode<>(node.left, remove(node.right, replacement), replacement));
                        }
                    }
                };
            });
    }

    public static final void main(String[] args) {
        Consumer<String> process = System.out::println;
        
        Optional<TreeNode<String>> tree = Optional.empty();
        tree = add(tree, "C");
        tree = add(tree, "D");
        tree = add(tree, "A");
        tree = add(tree, "B");
        tree = add(tree, "A");
        tree = add(tree, "K");
        tree = add(tree, "G");
        tree = add(tree, "E");
        tree = add(tree, "H");

        System.out.println("=========== in-order DFS traversal ===========");
        in_order_dfs_traversal(tree, process);
        System.out.println("=========== pre-order DFS traversal ===========");
        pre_order_dfs_traversal(tree, process);
        System.out.println("=========== post-order DFS traversal ===========");
        post_order_dfs_traversal(tree, process);
        System.out.println("=========== BFS traversal ===========");
        bfs_traversal(tree, process);
        System.out.println("=========== Maximum ===========");
        maximum(tree).ifPresent(process);
        System.out.println("=========== Minimum ===========");
        minimum(tree).ifPresent(process);
        System.out.println("=========== Depth ==========");
        System.out.println(depth(tree));

        System.out.println("=========== Removing C ==========");
        tree = remove(tree, "C");
        in_order_dfs_traversal(tree, process);   
    }
}

